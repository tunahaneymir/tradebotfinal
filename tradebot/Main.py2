"""
PA + RL Trading Bot - Main Entry Point (FUTURES PAPER TRADING)

Usage:
    python Main.py --mode paper
    python Main.py --mode live  # After 6 months training
"""

import sys
import time
import signal
import argparse
import os
from pathlib import Path
from typing import Optional
import yaml
from dotenv import load_dotenv  # .env desteƒüi

# Load environment variables
load_dotenv()

# Infrastructure
from infrastructure import InfrastructureManager
from infrastructure.sl_tracker import SLTracker  # YENƒ∞!

# Core PA System
from core.trend_detector import TrendDetector
from core.zone_detector import ZoneDetector
from core.choch_detector import ChochDetector
from core.entry_system import EntrySystem
from core.exit_system import ExitSystem

# Adaptive
from adaptive.reentry_manager import ReentryManager

# RL System
from rl.rl_agent_ppo import PPOAgent
from rl.state_builder import StateBuilder
from rl.setup_scorer import SetupScorer
from rl.gate_system import GateSystem
from rl.anti_fomo import AntiFOMO
from rl.anti_revenge import AntiRevenge
from rl.overtrading_detector import OvertradingDetector

# Learning
from learning.continuous_learning import ContinuousLearning
from learning.experience_buffer import ExperienceBuffer
# SystemIntegrator kaldƒ±rƒ±ldƒ± - artƒ±k Main.py i√ßinde

# Position Agent (ZATEN VAR!)
from position_agent.coin_selector import CoinSelector
from position_agent.executor_binance_futures import BinanceFuturesExecutor  # YENƒ∞!
from position_agent.position_agent import PositionAgent
from position_agent.rmm_engine import RMMEngine

# Data
from data.data_fetcher import DataFetcher


class TradingBot:
    """
    PA + RL Trading Bot - FUTURES Paper Trading
    
    6 Ay Plan:
    - Paper trading ile √∂ƒürenme
    - RL agent eƒüitimi
    - Performans tracking
    - 6 ay sonra Live Trading'e ge√ßi≈ü
    """
    
    def __init__(self, config_path: str = "config.yaml", mode: str = "paper"):
        """
        Initialize trading bot
        
        Args:
            config_path: Path to configuration file
            mode: 'paper' or 'live'
        """
        self.mode = mode
        self.running = False
        
        print("\n" + "="*60)
        print(f"ü§ñ PA + RL TRADING BOT - {mode.upper()} MODE")
        print(f"üíπ Market: BINANCE FUTURES (https://demo.binance.com)")
        print("="*60)
        
        # Load configuration
        self.config = self._load_config(config_path)
        
        # Verify mode
        if mode == "live" and not self._verify_live_ready():
            print("\n‚ö†Ô∏è  UYARI: Live trading i√ßin 6 aylƒ±k paper trading gerekli!")
            print("    √ñnce --mode paper ile ba≈ülayƒ±n.\n")
            sys.exit(1)
        
        # Initialize infrastructure
        print("\nüì¶ Initializing infrastructure...")
        self.infra = InfrastructureManager(self.config)
        
        # Initialize SL Tracker (G√ºnl√ºk SL limiti)
        print("üì¶ Initializing SL tracker...")
        self.sl_tracker = SLTracker(self.config['risk'])
        
        # Initialize data fetcher
        print("üì¶ Initializing data fetcher...")
        self.data_fetcher = DataFetcher(
            source=self.config['exchange']['data_source']
        )
        
        # Initialize PA components
        print("üì¶ Initializing PA components...")
        self.trend_detector = TrendDetector(self.config['trend'])
        self.zone_detector = ZoneDetector(self.config['zones'])
        self.choch_detector = ChochDetector(self.config['entry']['choch'])
        self.entry_system = EntrySystem(self.config['entry'])
        self.exit_system = ExitSystem(self.config['exit'])
        
        # Initialize adaptive
        print("üì¶ Initializing adaptive systems...")
        self.reentry_manager = ReentryManager(self.config['reentry'])
        
        # Initialize RL components
        print("üì¶ Initializing RL components...")
        self.state_builder = StateBuilder()
        self.setup_scorer = SetupScorer(self.config['rl'])
        self.gate_system = GateSystem(self.config['rl']['gates'])
        
        # Initialize behavioral guards
        print("üì¶ Initializing behavioral guards...")
        self.anti_fomo = AntiFOMO(self.config['behavior']['anti_fomo'])
        self.anti_revenge = AntiRevenge(self.config['behavior']['anti_revenge'])
        self.overtrading_detector = OvertradingDetector(
            self.config['behavior']['anti_overtrading']
        )
        
        # Initialize RL Agent
        print("üì¶ Initializing RL agent...")
        model_path = self.config.get('rl', {}).get('model_path')
        if model_path and Path(model_path).exists():
            self.agent = PPOAgent.load(model_path)
            print(f"   ‚úÖ Loaded model from: {model_path}")
        else:
            print("   ‚ö†Ô∏è  No trained model found, starting fresh")
            self.agent = None
        
        # Initialize Position Management
        print("üì¶ Initializing position management...")
        self.coin_selector = CoinSelector(self.config['trading']['coin_selection'])
        
        # RMM Engine i√ßin config hazƒ±rla
        from position_agent.interfaces import RMMConfig
        rmm_config = RMMConfig(
            base_risk_pct=self.config['risk']['base_risk_pct'],
            max_leverage=self.config['risk']['max_leverage'],
            daily_r_budget=self.config['risk'].get('daily_sl_limit', 5),
            weekly_dd_limit_r=self.config['risk'].get('weekly_sl_limit', 999),
            enable_rl_risk_factor=self.config['risk'].get('enable_rl_risk_factor', True),
            re_entry_risk_factor=self.config['risk'].get('re_entry_risk_factor', 0.5)
        )
        self.rmm_engine = RMMEngine(rmm_config)
        
        # Initialize Executor (Paper or Live)
        print(f"üì¶ Initializing executor ({mode} mode)...")
        if mode == "paper":
            self.executor = BinanceFuturesExecutor(self.config['exchange'])
            print("   ‚úÖ Binance Futures Demo executor ready!")
            print("   üí∞ Demo balance will be used (https://demo.binance.com)")
        else:
            # Live trading - demo_mode = false
            live_config = self.config['exchange'].copy()
            live_config['demo_mode'] = False
            self.executor = BinanceFuturesExecutor(live_config)
            print("   ‚ö†Ô∏è  LIVE TRADING ACTIVE - REAL MONEY!")
        
        # Position Agent (Simplified - RMM + Executor)
        print("üì¶ Initializing position agent...")
        # position_agent.py'deki PositionAgent yerine direkt kullanƒ±m
        # √á√ºnk√º position_agent.py basit bir wrapper
        
        # Initialize learning system
        print("üì¶ Initializing learning system...")
        if self.config['learning']['enabled']:
            self.experience_buffer = ExperienceBuffer(
                max_size=self.config['learning']['buffer_size']
            )
            self.learning = ContinuousLearning(
                self.config['learning'],
                self.infra
            )
            print("   ‚úÖ 6-month learning program activated!")
        else:
            self.experience_buffer = None
            self.learning = None
        
        print("\n‚úÖ Bot initialized successfully!")
        print("="*60 + "\n")
    
    def start(self):
        """Start the trading bot"""
        if self.running:
            print("‚ö†Ô∏è  Bot already running")
            return
        
        try:
            # Start infrastructure
            self.infra.start_all()
            
            # Start learning system
            if self.learning:
                self.learning.start_training_loop()
            
            self.running = True
            
            print(f"\nüöÄ Starting {self.mode.upper()} trading loop...")
            if self.mode == "paper":
                print("üìö 6-month learning program active")
                print("üí° Bot will learn from paper trades before going live\n")
            
            # Run main loop
            self._main_loop()
            
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Keyboard interrupt received")
            self.stop()
        except Exception as e:
            print(f"\n\n‚ùå Fatal error: {e}")
            import traceback
            traceback.print_exc()
            self.stop()
            raise
    
    def stop(self):
        """Stop the trading bot"""
        if not self.running:
            return
        
        print("\n" + "="*60)
        print("üõë STOPPING BOT")
        print("="*60)
        
        try:
            # Stop learning
            if self.learning:
                self.learning.stop()
            
            # Close positions (in live mode)
            if self.mode == "live":
                print("   Closing open positions...")
                # TODO: Close positions
            
            # Stop infrastructure
            self.infra.stop_all()
            
            self.running = False
            
            print("\n‚úÖ Bot stopped successfully!")
            print("="*60 + "\n")
            
        except Exception as e:
            print(f"\n‚ùå Error during shutdown: {e}")
    
    def _main_loop(self):
        """Main trading loop - GER√áEK ƒ∞MPLEMENTASYON"""
        iteration = 0
        
        while self.running:
            try:
                iteration += 1
                print(f"\n{'='*60}")
                print(f"[Iteration {iteration}] Starting cycle...")
                print(f"{'='*60}")
                
                # Check SL limit
                can_trade, reason = self.sl_tracker.can_trade()
                if not can_trade:
                    print(f"‚ö†Ô∏è  {reason}")
                    print("   Waiting until tomorrow...\n")
                    time.sleep(300)  # 5 minutes
                    continue
                
                # Select coins to trade
                print("\nüìä Selecting coins...")
                # Coin selector returns top 20 watchlist
                watchlist = self.coin_selector.select_coins()
                
                if not watchlist:
                    print("   No coins in watchlist (filters not passed)")
                    time.sleep(60)
                    continue
                
                print(f"   ‚úÖ Watchlist: {len(watchlist)} coins")
                print(f"      {', '.join(watchlist[:10])}{'...' if len(watchlist) > 10 else ''}")
                
                # Analyze all watchlist coins and find best setups
                print("\nüîç Analyzing watchlist for best setups...")
                
                # Store all valid setups with scores
                all_setups = []
                
                # Get current equity state
                equity_state = self._get_equity_state()
                
                # Process each coin
                for symbol in watchlist:
                    try:
                        # Quick PA check
                        data = self.data_fetcher.fetch_ohlcv(symbol, '15m', limit=100)
                        if data is None or len(data) < 50:
                            continue
                        
                        # Quick filters
                        trend = self.trend_detector.detect(data)
                        if trend == "SIDEWAYS":
                            continue
                        
                        zones = self.zone_detector.detect_zones(data)
                        if not zones:
                            continue
                        
                        best_zone = max(zones, key=lambda z: z.get('quality', 0))
                        if best_zone.get('quality', 0) < 4:
                            continue
                        
                        choch = self.choch_detector.detect(data, trend)
                        if not choch or choch.get('strength', 0) < 0.4:
                            continue
                        
                        # Generate candidates
                        candidates = self.entry_system.generate_candidates(
                            data=data, zone=best_zone, choch=choch, trend=trend
                        )
                        
                        if not candidates:
                            continue
                        
                        # Score and filter
                        for candidate in candidates:
                            score = self.setup_scorer.score_setup(
                                candidate=candidate,
                                zone_quality=best_zone.get('quality', 0),
                                choch_strength=choch.get('strength', 0),
                                trend=trend
                            )
                            candidate['setup_score'] = score
                            candidate['symbol'] = symbol
                            candidate['trend'] = trend
                            candidate['zone'] = best_zone
                            candidate['choch'] = choch
                            
                            # Gate validation
                            passed, _ = self.gate_system.validate(candidate)
                            if passed and score >= 40:
                                all_setups.append(candidate)
                        
                    except Exception as e:
                        continue
                
                # Sort by score and take top 5
                all_setups.sort(key=lambda x: x['setup_score'], reverse=True)
                top_setups = all_setups[:5]
                
                if not top_setups:
                    print("   ‚ö†Ô∏è  No valid setups found in watchlist")
                    time.sleep(60)
                    continue
                
                print(f"\n‚úÖ Found {len(all_setups)} valid setups")
                print(f"   Trading top {len(top_setups)}:")
                for setup in top_setups:
                    print(f"   - {setup['symbol']}: Score {setup['setup_score']:.0f}")
                
                # Now trade the top setups
                for setup in top_setups:
                    try:
                        print(f"\n--- Processing {symbol} ---")
                        
                        # Fetch market data
                        data = self.data_fetcher.fetch_ohlcv(
                            symbol=symbol,
                            timeframe=self.config['trading']['timeframes']['entry'],
                            limit=500
                        )
                        
                        if data is None or len(data) < 100:
                            print(f"   ‚ö†Ô∏è  Insufficient data for {symbol}")
                            continue
                        
                        # === PA ANALYSIS ===
                        print("   üîç PA Analysis...")
                        
                        # Trend detection
                        trend = self.trend_detector.detect(data)
                        if trend == "SIDEWAYS":
                            print(f"   ‚ö†Ô∏è  Sideways market, skipping")
                            continue
                        
                        print(f"   Trend: {trend}")
                        
                        # Zone detection
                        zones = self.zone_detector.detect_zones(data)
                        if not zones:
                            print(f"   ‚ö†Ô∏è  No zones found")
                            continue
                        
                        # Get best zone
                        best_zone = max(zones, key=lambda z: z.get('quality', 0))
                        print(f"   Zone quality: {best_zone.get('quality', 0):.1f}/10")
                        
                        # ChoCH detection
                        choch = self.choch_detector.detect(data, trend)
                        if not choch or choch.get('strength', 0) < 0.4:
                            print(f"   ‚ö†Ô∏è  No valid ChoCH")
                            continue
                        
                        print(f"   ChoCH strength: {choch.get('strength', 0):.2f}")
                        
                        # Generate PA candidates
                        pa_candidates = self.entry_system.generate_candidates(
                            data=data,
                            zone=best_zone,
                            choch=choch,
                            trend=trend
                        )
                        
                        if not pa_candidates:
                            print(f"   ‚ö†Ô∏è  No valid setups")
                            continue
                        
                        print(f"   ‚úÖ {len(pa_candidates)} candidates generated")
                        
                        # === SETUP SCORING ===
                        for candidate in pa_candidates:
                            score = self.setup_scorer.score_setup(
                                candidate=candidate,
                                zone_quality=best_zone.get('quality', 0),
                                choch_strength=choch.get('strength', 0),
                                trend=trend
                            )
                            candidate['setup_score'] = score
                        
                        # Filter by gates
                        passed_candidates = []
                        for candidate in pa_candidates:
                            passed, reason = self.gate_system.validate(candidate)
                            if passed:
                                passed_candidates.append(candidate)
                        
                        if not passed_candidates:
                            print(f"   ‚ö†Ô∏è  No candidates passed gates")
                            continue
                        
                        print(f"   ‚úÖ {len(passed_candidates)} passed gates")
                        
                        # === BEHAVIORAL GUARDS ===
                        # Anti-FOMO check
                        fomo_score = self.anti_fomo.calculate_fomo_score(data, candidate)
                        if fomo_score >= 50:
                            print(f"   ‚ö†Ô∏è  FOMO blocked (score: {fomo_score})")
                            continue
                        
                        # Anti-Revenge check
                        can_trade_revenge = self.anti_revenge.can_trade()
                        if not can_trade_revenge:
                            cooldown = self.anti_revenge.get_cooldown_remaining()
                            print(f"   ‚ö†Ô∏è  Revenge trading blocked ({cooldown}min cooldown)")
                            continue
                        
                        # Anti-Overtrading check
                        can_trade_ot = self.overtrading_detector.can_trade()
                        if not can_trade_ot:
                            print(f"   ‚ö†Ô∏è  Overtrading limit reached")
                            continue
                        
                        # === RL DECISION ===
                        if self.agent:
                            print("   ü§ñ RL Agent decision...")
                            
                            # Build state
                            state = self.state_builder.build_state(
                                data=data,
                                candidates=passed_candidates,
                                zone=best_zone,
                                choch=choch,
                                trend=trend
                            )
                            
                            # Agent decides
                            action, confidence = self.agent.select_action(state)
                            
                            if action == 0:  # SKIP
                                print(f"   ‚ö†Ô∏è  RL Agent: SKIP (confidence: {confidence:.2f})")
                                continue
                            
                            direction = "BUY" if action == 1 else "SELL"
                            print(f"   ‚úÖ RL Agent: {direction} (confidence: {confidence:.2f})")
                        else:
                            # No RL agent, use best candidate
                            direction = "BUY" if trend == "UPTREND" else "SELL"
                            confidence = 0.5
                            print(f"   üìä PA Only: {direction}")
                        
                        # === EXECUTE TRADE ===
                        best_candidate = max(passed_candidates, key=lambda c: c.get('setup_score', 0))
                        
                        print(f"\n   üí∞ Executing {direction} trade:")
                        print(f"      Entry: ${best_candidate['entry']:.2f}")
                        print(f"      Stop: ${best_candidate['stop']:.2f}")
                        print(f"      TP: ${best_candidate['tp_list'][0]:.2f}")
                        print(f"      Setup Score: {best_candidate['setup_score']:.0f}/100")
                        
                        # Create RMM Intent
                        from position_agent.interfaces import RMMIntent
                        
                        intent = RMMIntent(
                            symbol=symbol,
                            side="LONG" if direction == "BUY" else "SHORT",
                            entry=best_candidate['entry'],
                            stop=best_candidate['stop'],
                            tp_list=best_candidate['tp_list'],
                            rl_confidence=confidence
                        )
                        
                        # Build order via RMM
                        order, guard = self.rmm_engine.build_order(equity_state, intent)
                        
                        if not guard.allowed or order is None:
                            print(f"   ‚ùå Trade blocked: {guard.reason}")
                            if guard.details:
                                print(f"      Details: {guard.details}")
                            continue
                        
                        # Execute order
                        try:
                            trade_id = self.executor.place_order(order)
                            print(f"   ‚úÖ Trade executed! ID: {trade_id}")
                            print(f"      Qty: {order.qty_coin:.6f}")
                            print(f"      Leverage: {order.leverage:.1f}x")
                            print(f"      Risk: ${equity_state.equity_usdt * order.risk_pct_used:.2f}")
                            
                            # Store experience
                            if self.experience_buffer and self.agent:
                                self.experience_buffer.add(
                                    state=state,
                                    action=direction,
                                    reward=0,  # Updated when trade closes
                                    next_state=None,
                                    done=False
                                )
                        except Exception as e:
                            print(f"   ‚ùå Execution failed: {e}")
                        
                    except Exception as e:
                        print(f"   ‚ùå Error processing {symbol}: {e}")
                        import traceback
                        traceback.print_exc()
                        continue
                
                # Check for closed trades
                self._check_closed_trades()
                
                # Update dashboard
                self.infra.update_dashboard()
                
                # Sleep until next cycle
                print(f"\n{'='*60}")
                print(f"[Iteration {iteration}] Cycle complete. Sleeping...")
                print(f"{'='*60}\n")
                time.sleep(60)
                
            except KeyboardInterrupt:
                raise
            except Exception as e:
                print(f"\n‚ùå Error in main loop: {e}")
                import traceback
                traceback.print_exc()
                self.infra.send_notification("critical", f"Main loop error: {e}")
                time.sleep(5)
    
    def _get_equity_state(self):
        """Get current equity state for RMM"""
        from position_agent.interfaces import EquityState
        
        # Get balance from executor
        balance = self.executor.get_account_balance() if hasattr(self.executor, 'get_account_balance') else 10000.0
        
        return EquityState(
            equity_usdt=balance,
            daily_r_used=0.0,  # TODO: Track from database
            weekly_dd_r=0.0,   # TODO: Track from database
        )
    
    def _check_closed_trades(self):
        """Check and process closed trades"""
        try:
            # Executor'dan kapalƒ± trade'leri al
            if not hasattr(self.executor, 'positions'):
                return
            
            for symbol in list(self.executor.positions.keys()):
                # Get current price
                price = self._get_current_price(symbol)
                if price == 0:
                    continue
                
                # Check with executor
                closed_trades = self.executor.on_price(symbol, price)
                
                # Process closed trades
                for trade in closed_trades:
                    r_realized = trade.r_realized
                    
                    print(f"\nüí∞ Trade closed: {symbol}")
                    print(f"   R: {r_realized:+.2f}")
                    print(f"   Risk: %{trade.risk_pct*100:.1f}")
                    
                    # Record with SL tracker
                    self.sl_tracker.record_trade(r_realized)
                    
                    # Update RMM equity state (for daily/weekly tracking)
                    equity_state = self._get_equity_state()
                    self.rmm_engine.on_trade_closed_update_r(
                        equity=equity_state,
                        r_realized=r_realized,
                        risk_pct_used=trade.risk_pct or 0.03
                    )
                    
                    # Update learning
                    if self.learning:
                        self.learning.record_trade_result(trade)
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error checking closed trades: {e}")
            import traceback
            traceback.print_exc()
    
    def _get_current_price(self, symbol: str) -> float:
        """Get current price for a symbol"""
        try:
            data = self.data_fetcher.fetch_ohlcv(symbol, '1m', limit=1)
            return data['close'].iloc[-1] if data is not None and len(data) > 0 else 0.0
        except Exception:
            return 0.0
        """Verify bot is ready for live trading (after 6 months paper)"""
        # TODO: Check performance metrics, training duration, etc.
        # For now, just check if model exists
        model_path = self.config.get('rl', {}).get('model_path')
        return model_path and Path(model_path).exists()
    
    def _load_config(self, config_path: str) -> dict:
        """Load configuration from file"""
        config_file = Path(config_path)
        
        if not config_file.exists():
            print(f"‚ö†Ô∏è  Config file not found: {config_path}")
            print("üìù Using default configuration")
            config = self._default_config()
        else:
            try:
                with open(config_file) as f:
                    config = yaml.safe_load(f)
                print(f"‚úÖ Configuration loaded: {config_path}")
            except Exception as e:
                print(f"‚ùå Error loading config: {e}")
                print("üìù Using default configuration")
                config = self._default_config()
        
        # Override with environment variables (if .env exists)
        if os.getenv('BINANCE_API_KEY'):
            config['exchange']['api_key'] = os.getenv('BINANCE_API_KEY')
            print("   ‚úÖ API Key loaded from .env")
        
        if os.getenv('BINANCE_API_SECRET'):
            config['exchange']['api_secret'] = os.getenv('BINANCE_API_SECRET')
            print("   ‚úÖ API Secret loaded from .env")
        
        if os.getenv('TELEGRAM_BOT_TOKEN'):
            config['telegram']['bot_token'] = os.getenv('TELEGRAM_BOT_TOKEN')
            config['telegram']['enabled'] = True
            print("   ‚úÖ Telegram token loaded from .env")
        
        if os.getenv('TELEGRAM_CHAT_ID'):
            config['telegram']['chat_id'] = os.getenv('TELEGRAM_CHAT_ID')
        
        return config
    
    def _default_config(self) -> dict:
        """Default configuration"""
        return {
            "bot": {
                "name": "PA+RL Trading Bot",
                "version": "1.0.0"
            },
            "paths": {
                "data_dir": "state",
                "database_path": "data/trades.db",
                "logs_dir": "logs",
                "models_dir": "models"
            },
            "exchange": {
                "name": "binance",
                "market_type": "futures",  # FUTURES!
                "data_source": "simulation"
            },
            "telegram": {
                "enabled": False
            },
            "risk": {
                "base_risk_pct": 0.03,        # %3 per trade ‚úÖ
                "daily_sl_limit": 5,          # G√ºnde max 5 SL ‚úÖ
                "weekly_sl_limit": 999,       # Haftalƒ±k limit yok ‚úÖ
                "max_leverage": 5.0,
                "max_positions": 5,           # Max 5 pozisyon ‚úÖ
                "re_entry_risk_factor": 0.5,
                "enable_rl_risk_factor": True
            },
            "trading": {
                "timeframes": {
                    "trend": "4H",
                    "zone": "1H",
                    "entry": "15M"
                },
                "max_positions": 5,           # Max 5 pozisyon ‚úÖ
                "coin_selection": {
                    "enabled": True,
                    "max_coins": 20,          # Top 20 watchlist ‚úÖ
                    "scan_all": True
                }
            },
            "trend": {
                "ema_fast": 20,
                "ema_slow": 50
            },
            "zones": {
                "min_touches": 2,
                "min_quality": 4
            },
            "entry": {
                "choch": {"min_strength": 0.4}
            },
            "exit": {
                "take_profit": {
                    "tp1": {"ratio": 0.5, "rr": 1.5},
                    "tp2": {"ratio": 0.3, "rr_min": 2.5},
                    "tp3": {"ratio": 0.2, "dynamic": True}
                }
            },
            "reentry": {
                "enabled": True,
                "max_attempts": 2
            },
            "rl": {
                "gates": {
                    "enabled": True,
                    "min_zone_quality": 4
                }
            },
            "behavior": {
                "anti_fomo": {"enabled": True, "threshold": 50},
                "anti_revenge": {"enabled": True},
                "anti_overtrading": {"enabled": True}
            },
            "learning": {
                "enabled": True,
                "buffer_size": 100000
            }
        }


def setup_signal_handlers(bot: TradingBot):
    """Setup signal handlers for graceful shutdown"""
    def signal_handler(signum, frame):
        print(f"\n\n‚ö†Ô∏è  Signal {signum} received")
        bot.stop()
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="PA + RL Trading Bot")
    parser.add_argument("--config", default="config.yaml", help="Config file path")
    parser.add_argument("--mode", default="paper", 
                       choices=["paper", "live"], 
                       help="Trading mode (paper for first 6 months)")
    args = parser.parse_args()
    
    # Warning for live mode
    if args.mode == "live":
        print("\n" + "="*60)
        print("‚ö†Ô∏è  LIVE TRADING MODE SELECTED")
        print("="*60)
        response = input("Are you sure? This will use REAL money! (yes/no): ")
        if response.lower() != "yes":
            print("Cancelled.")
            sys.exit(0)
    
    # Create bot
    bot = TradingBot(config_path=args.config, mode=args.mode)
    
    # Setup signal handlers
    setup_signal_handlers(bot)
    
    # Start bot
    bot.start()


if __name__ == "__main__":
    main()
